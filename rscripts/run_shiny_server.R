# load required packages
library(yaml)
library(here)
library(shiny)
library(scales)
library(rhdf5)
library(tidyverse)


###############################################################################
# Get information from the YAML
###############################################################################

args <- commandArgs(TRUE)
if (!is.na(args[1])) {
  yaml <- yaml::read_yaml(args[1])
} else {
  return("Provide the path to the interactive viz yaml file
         'interactive_viz_config.yaml' generated by a riboviz run.")
}
if (!is.na(args[2])) {
  port_num <- args[strtoi(2)]  # use strtoi() to convert to int, avoids bug
} else {
  port_num <- 4254
}


# use this function to pull the sample names and directories from the yaml
# the sample names and dirs will be used to find data files.
FindSampleNames <- function(yaml_file) {

  # if there are no entries in fq_files, data is multiplexed
  if (is.null(yaml_file$fq_files)) {
    # get the names from the barcodes file
    
    # this is location of the sample sheet
    sample_sheet_loc <- here::here(yaml_file$dir_in, yaml_file$sample_sheet)

    # get the sample names from it
    sample_names <- readr::read_tsv(sample_sheet_loc)$SampleID
    
  } else {
    # it is not multiplexed, read the names from the yaml_file
    sample_names <- names(yaml_file$fq_files)
  }

  # construct the paths to the dirs
  sample_dir_paths <- here::here(yaml_file$dir_out, sample_names)

  names(sample_dir_paths) <- sample_names

  # in the case where reads are not demultiplexed, as in Tag3 in the vignette
  # remove that from the vector
  do_dirs_exist <- unlist(lapply(sample_dir_paths, dir.exists))

  # retain only sample names for dirs that exist
  these_dirs_exist <- names(do_dirs_exist[do_dirs_exist == TRUE])

  sample_dir_paths_that_exist <-
    sample_dir_paths[names(sample_dir_paths) %in% these_dirs_exist]

  return(sample_dir_paths_that_exist)
}

# use the function
sample_names <- FindSampleNames(yaml)

###############################################################################
# Data acquisition
###############################################################################

### Read counts bar plot
# rename the categories for the graph
graph_cats <- data.frame(
  Description = c(
    "Demultiplexed reads",
    "Reads after removal of sequencing library adapters",
    "Reads with rRNA & other contaminating reads removed by alignment to rRNA index files",
    "Reads after trimming of 5' mismatches & removing those with >2 mismatches", 
    "Reads aligned to ORFs index files",
    "Deduplicated reads"
  ),
  short_name = c(
    "Reads after demultiplexing",
    "Reads after adapter removal",
    "Reads after contaminant removal",
    "Reads after trimming of 5' mismatches",
    "Reads aligned to ORFs",
    "Reads after deduplication"
  )
)

# Load the data frame and add the short names
read_counts_df <-
  readr::read_tsv(
    here::here(yaml$dir_out, "read_counts_per_file.tsv"), 
    skip = 5
  ) %>%
  dplyr::left_join(graph_cats, by = "Description") %>%
  dplyr::filter(
    Description %in% graph_cats$Description &
      !is.na(SampleName) & SampleName != "Unassigned"
  )

# find which categories actually occur
occurring_cats <- unique(read_counts_df$short_name)

read_counts_df <- read_counts_df %>%
  dplyr::mutate(
    short_name = factor(
      short_name,
      levels = graph_cats$short_name[
        graph_cats$short_name %in% occurring_cats
      ]
    )
  )

### Read length distributions
read_length_df <- lapply(sample_names, function(x) {
  # path to the read length file
  file_loc <- paste0(x, "/read_counts_by_length.tsv")
  # read it in
  return(readr::read_tsv(file_loc, skip = 4))
}) %>%
  dplyr::bind_rows(.id = "samplez")

### Periodicity line plot
periodicity_df <- lapply(sample_names, function(x) {
  # path to the read length file
  file_loc <- paste0(x, "/metagene_start_stop_read_counts.tsv")
  # read it in
  return(readr::read_tsv(file_loc, skip = 4))
}) %>%
  dplyr::bind_rows(.id = "samplez")

### Read counts by frame bar plot
frame_bar_df <- lapply(sample_names, function(x) {
  # path to the read length file
  file_loc <- paste0(x, "/read_frame_per_ORF.tsv")
  # read it in
  return(readr::read_tsv(file_loc, skip = 4))
}) %>%
  dplyr::bind_rows(.id = "samplez") %>%
  dplyr::group_by(samplez) %>%
  dplyr::summarise(
    Frame_0 = sum(Ct_fr0),
    Frame_1 = sum(Ct_fr1),
    Frame_2 = sum(Ct_fr2)
  ) %>%
  tidyr::pivot_longer(cols = where(is.numeric),
               names_to = "Frame",
               values_to = "Count")

### Read counts by frame boxplot
frame_box_df <- lapply(sample_names, function(x) {
  # path to the read length file
  file_loc <- paste0(x, "/read_frame_per_ORF.tsv")
  # read it in
  return(readr::read_tsv(file_loc, skip = 4))
}) %>%
  dplyr::bind_rows(.id = "samplez") %>%
  dplyr::mutate(
    Frame_0 = Ct_fr0 / (Ct_fr0 + Ct_fr1 + Ct_fr2),
    Frame_1 = Ct_fr1 / (Ct_fr0 + Ct_fr1 + Ct_fr2),
    Frame_2 = Ct_fr2 / (Ct_fr0 + Ct_fr1 + Ct_fr2)
  ) %>%
  dplyr::select(samplez, gene, Frame_0, Frame_1, Frame_2) %>%
  tidyr::pivot_longer(names_to = "Frame", cols = 3:5)

### Position specific normalized reads
pos_sp_df <- lapply(sample_names, function(x) {
  # path to the read length file
  file_loc <- paste0(x, "/metagene_normalized_profile_start_stop.tsv")
  # read it in
  return(readr::read_tsv(file_loc, skip = 4))
}) %>%
  dplyr::bind_rows(.id = "samplez")

### collated TPMs
collated_tpms_df <-
  readr::read_tsv(
    here::here(yaml$dir_out, "TPMs_all_CDS_all_samples.tsv"), 
    skip = 4
  )

### Ribogrid
ribogrid_df <- lapply(sample_names, function(x) {
  # path to the read length file
  file_loc <- paste0(x, "/gene_position_length_counts_5start.tsv")
  # read it in
  return(readr::read_tsv(file_loc, skip = 4))
}) %>%
  dplyr::bind_rows(.id = "samplez")


### Gene features

# this likely needs some work, but depends on the exact format of the feature 
# file which isn't documented yet

if (any(names(yaml) == "features_file")) {
  if (length(yaml$features_file) > 0) {
    features_df <- lapply(sample_names, function(x) {
      file_loc <- paste0(x, "/ORF_TPMs_vs_features.tsv")

      return(readr::read_tsv(file_loc, skip = 4))
    }) %>%
      dplyr::bind_rows(.id = "samplez")

    possible_features <- unique(features_df$Feature)
  }
}

###############################################################################
# Plotting
###############################################################################

### define the universal plot theme
plot_theme <- ggplot2::theme_bw() +
  ggplot2::theme(
    panel.background = element_blank(),
    panel.grid = element_blank(),
    text = element_text(size = 15)
  )

### Start the server
server <- function(input, output, session) {
  
  ##############################################################################
  # Read count summary
  ##############################################################################

  ### bar plot
  output$read_counts_bar_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      read_counts_df %>%
        dplyr::filter(SampleName %in% input$sample) %>%
        ggplot2::ggplot(., aes(SampleName, NumReads, fill = short_name)) +
        geom_col(position = position_dodge()) +
        plot_theme +
        scale_fill_discrete(name = NULL) +
        labs(x = NULL,
             y = "Read count",
             title = "Read counts per step") +
        guides(fill = guide_legend(ncol = 1)) +
        scale_y_continuous(labels = label_number_si())
    })
  })

  ##############################################################################
  # TPM summary
  ##############################################################################

  ### Sample to sample cors
  # load the TPM df
  cor.df <- collated_tpms_df %>%
    tibble::column_to_rownames("ORF")

  # get a fixed column order, alphabetical in this case
  cor.cols <- sort(names(cor.df))

  # create correlations, fix col order
  cor.df <- cor.df %>%
    dplyr::select(all_of(cor.cols)) %>%
    apply(., 2, log10) %>%
    na_if(.,-Inf) %>%
    cor(use = "pairwise.complete.obs")

  # remove lower triangle
  cor.df[lower.tri(cor.df)] <- NA

  # convert to a df and reshape
  cor.df2 <- tibble::as_tibble(cor.df, rownames = "samp1") %>%
    tidyr::pivot_longer(
      cols = where(is.numeric),
      names_to = "samp2",
      values_to = "R"
    ) %>%
    dplyr::filter(samp1 != samp2) %>%
    dplyr::mutate(
      samp1 = factor(samp1, levels = cor.cols),
      samp2 = factor(samp2, levels = cor.cols)
    )

  # find the floor of min correlation
  min.cor <- floor(min(cor.df2$R, na.rm = TRUE) * 10) / 10

  # plot it
  output$sample_cors_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      ggplot2::ggplot(
        cor.df2, 
        aes(samp1, samp2, fill = R, label = signif(R, 2))) +
        geom_raster() +
        scale_fill_viridis_c(
          option = "B",
          na.value = NA,
          limits = c(min.cor, 1)
        ) +
        ggplot2::theme(
          panel.background = element_blank(),
          text = element_text(size = 14),
          axis.text.x = element_text(
            angle = 45,
            vjust = 1,
            hjust = 1
          ),
          panel.grid.major.x = element_line(color = "grey50", linetype = 3),
          axis.ticks = element_blank()
        ) +
        labs(x = NULL,
             y = NULL,
             title = expression(paste(
               "Pairwise correlations based on ", log[10], "(TPM)"
             ))) +
        geom_text()
    })
  })

  ### Abundance of specific gene compared to all
  output$tpm_density_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      collated_tpms_df %>%
        tidyr::pivot_longer(where(is.numeric),
                     names_to = "samplez",
                     values_to = "tpm") %>%
        dplyr::filter(samplez %in% input$sample) %>%
        dplyr::mutate(
          labz = ifelse(ORF %in% input$gene, ORF, NA),
          xint = ifelse(ORF %in% input$gene, tpm, NA)
        ) %>%
        ggplot2::ggplot(., aes(x = tpm, fill = samplez)) +
        geom_density(alpha = 0.5) +
        geom_vline(aes(xintercept = xint), size = 1) +
        scale_x_log10(labels = label_number_si()) +
        facet_wrap( ~ samplez) +
        scale_fill_discrete(guide = "none") +
        plot_theme +
        labs(title = "TPM distributions",
             x = expression(paste(log[10], "(TPM)")),
             y = "Density")
    })
  })

  ##############################################################################
  # Read length distributions
  ##############################################################################

  ### Read length distribution plot
  output$read_length_dist_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      read_length_df %>%
        dplyr::filter(samplez %in% input$sample) %>%
        ggplot2::ggplot(., aes(Length, Counts, fill = samplez)) +
        geom_col(width = 1) +
        facet_wrap( ~ samplez, scales = "free_y") +
        scale_fill_discrete(name = NULL, guide = "none") +
        plot_theme +
        labs(title = "Read length distributions",
             x = "Read length",
             y = "Read counts") +
        scale_x_continuous(breaks = seq(10, 50, 5)) +
        scale_y_continuous(breaks = breaks_pretty(n = 4),
                           labels = label_number_si())
    })
  })

  ##############################################################################
  # 3nt periodicity
  ##############################################################################

  ### Periodicity metagene plot for both 5' and 3' end as a line plot
  output$periodicity_line_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      periodicity_df %>% 
        dplyr::mutate(End = factor(End, levels = c("5'", "3'"))) %>%
        dplyr::filter(samplez %in% input$sample) %>%
        ggplot2::ggplot(., aes(x = Pos, y = Counts, color = samplez)) +
        geom_line() +
        scale_color_discrete(name = NULL, guide = "none") +
        facet_grid(cols = vars(samplez),
                   rows = vars(End),
                   scales = "free_y") +
        labs(title = "3-nucleotide periodicity",
             x = "Codon position",
             y = "Read counts") +
        plot_theme +
        scale_y_continuous(labels = label_number_si())
    })
  })

  ### Read counts per frame as a bar plot
  output$frame_counts_bar_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      frame_bar_df %>%
        dplyr::filter(samplez %in% input$sample) %>%
        ggplot2::ggplot(., aes(x = Frame, y = Count, fill = samplez)) +
        geom_bar(stat = "identity", pos = "dodge") +
        scale_fill_discrete(name = NULL) +
        labs(title = "Read counts per frame",
             x = NULL,
             y = "Read counts") +
        plot_theme +
        scale_color_discrete(guide = "none") +
        scale_y_continuous(labels = label_number_si())
    })
  })

  ### Proportion of reads per frame for each gene as a boxplot
  output$frame_proportions_boxplot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      frame_box_df %>%
        dplyr::filter(samplez %in% input$sample) %>%
        ggplot2::ggplot(., aes(x = Frame, y = value, fill = samplez)) +
        labs(y = "Proportion",
             title = "Proportion of reads per frame per gene",
             x = NULL) +
        scale_fill_discrete(name = NULL) +
        geom_boxplot() +
        plot_theme
    })
  })

  ##############################################################################
  # Position specific normalized reads
  ##############################################################################

  ### 3' end
  output$pos_sp_plot3 <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      pos_sp_df %>%
        dplyr::filter(End == "3'" & samplez %in% input$sample) %>%
        ggplot2::ggplot(., aes(Position, Mean, color = samplez)) +
        geom_line() +
        facet_grid(End ~ samplez, scales = "free") +
        plot_theme +
        scale_color_discrete(guide = "none")
    })
  })

  ### 5' end
  output$pos_sp_plot5 <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      pos_sp_df %>%
        dplyr::filter(End == "5'" & samplez %in% input$sample) %>%
        ggplot2::ggplot(., aes(Position, Mean, color = samplez)) +
        geom_line() +
        facet_grid(End ~ samplez, scales = "free") +
        plot_theme +
        scale_color_discrete(guide = "none")
    })
  })

  #############################################################################
  # Ribogrids
  #############################################################################

  ### Ribogrid plot
  output$ribogrid_plot <- shiny::renderPlot({
    input$apply_changes
      shiny::isolate({
      ribogrid_df %>%
        dplyr::filter(
          samplez %in% input$sample &
            ReadLen >= min(input$ribogrid_len_range) &
            ReadLen <= max(input$ribogrid_len_range) &
            Pos >= min(input$ribogrid_pos_range) &
            Pos <= max(input$ribogrid_pos_range)
        ) %>%
        ggplot2::ggplot(., aes(Pos, ReadLen, fill = Counts)) +
        geom_raster() +
        scale_fill_gradient(low = "white", high = "navy") +
        plot_theme +
        labs(
          title = "Ribogrid", 
          x = "Position of 5' end of read", 
          y = "Read length"
        ) +
        facet_wrap(~ samplez)
    })
  })

  ### Ribogrid bar plot
  output$ribogridbar_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
      ribogrid_df %>%
        dplyr::filter(
          samplez %in% input$sample &
            ReadLen >= min(input$ribogrid_len_range) &
            ReadLen <= max(input$ribogrid_len_range) &
            Pos >= min(input$ribogrid_pos_range) &
            Pos <= max(input$ribogrid_pos_range)
        ) %>%
        ggplot2::ggplot(., aes(Pos, Counts)) +
        geom_col() +
        facet_grid(ReadLen ~ samplez) +
        plot_theme +
        labs(
          x = "Position of 5' end of read", 
          y = "Read count", 
          title = "Ribogrid (bar)"
        )
    })
  })

  ##############################################################################
  # Single-gene plots
  ##############################################################################

  # Go through h5 file for each sample and get the data for a specific gene
  # this is the part that is breaking it, I need to make this a normal variable
  # after it's done being reactive

  # Call genepos_range() for a vector of length two with the minimum and
  # maximum read positions
  genepos_range <- shiny::reactive(input$genepos_range)

  sgribogrid_df <- shiny::reactive({lapply(sample_names, function(x) {
    only_name <- stringr::str_split(x, "/") %>%
      unlist() %>%
      tail(1)
    
    file_loc <- here::here(
      yaml$dir_out, 
      paste0(only_name, "/", only_name, ".h5")
    )
    
    ret <-
      rhdf5::h5read(
        file_loc, 
        name = file.path(input$gene, yaml$dataset, "reads/data")
      ) %>%
      tibble::as_tibble() %>%
      tibble::rowid_to_column("read_length") %>%
      tidyr::pivot_longer(cols = starts_with("V"), names_to = "position") %>%
      dplyr::mutate(position = as.numeric(str_remove(position, "V")))

    rhdf5::h5closeAll()

    return(ret)
  }) %>%
    dplyr::bind_rows(.id = "samplez")})

  output$gene_specific_slider <- shiny::renderUI({

    newdf <- sgribogrid_df() %>%  # sgribogrid_df() not function; a shiny thing
      dplyr::filter(samplez %in% input$sample) %>%
      dplyr::group_by(samplez, position) %>%
      dplyr::summarise(total_reads = sum(value)) %>%
      dplyr::ungroup()

    shiny::sliderInput(
      "genepos_range",
      "Read position:",
      min = 0,
      max = nrow(newdf),
      value = c(0, nrow(newdf)),
      width = "50%"
    )
  })

  output$sgribogrid_plot <- shiny::renderPlot({
    input$apply_changes
    shiny::isolate({
    # single gene coverage
      sgribogrid_df() %>%   # sgribogrid_df() not function; a shiny thing
        dplyr::filter(samplez %in% input$sample) %>%
        dplyr::group_by(samplez, position) %>%
        dplyr::summarise(total_reads = sum(value)) %>%
        dplyr::ungroup() %>%
        ggplot2::ggplot(., aes(position, total_reads)) +
        geom_col(width = 1) +
        facet_wrap(~samplez, ncol = 1) +
        scale_x_continuous(limits = genepos_range()) +
        theme_bw() +
        ggplot2::theme(panel.grid = element_blank(),
              text = element_text(size = 14)) +
        labs(x = "Position",
             y = "Read count")
    })
  })


  ##############################################################################
  # Features
  ##############################################################################

  # Features are an optional file if it exists it's here
  # but the format isn't described so I'll hold off on this for now

  ### TPM vs other features
  if (any(names(yaml) == "features_file") &&
      length(yaml$features_file) > 0) {
    output$features_plot <- shiny::renderPlot({
      input$apply_changes
      shiny::isolate({
        if (input$gene2 == "") {
          features_df %>%
            dplyr::filter(samplez %in% input$sample &
                     Feature %in% input$feature) %>%
            ggplot2::ggplot(., aes(tpm, Value)) +
            geom_point() +
            geom_smooth(method = "lm") +
            facet_wrap(samplez ~ Feature, scales = "free") +
            scale_x_log10(
              labels = scales::trans_format(
                "log10", 
                scales::math_format(10 ^ .x)
              )
            ) +
            plot_theme +
            labs(x = expression(paste(log[10], "(TPM)"))) +
            scale_size_manual(values = c(4, 1), guide = "none")
        } else {
          features_df %>%
            dplyr::filter(samplez %in% input$sample &
                     Feature %in% input$feature) %>%
            dplyr::mutate(
              labz = ifelse(
                ORF == input$gene2, 
                "a_label", 
                "no_lab"
              )
            ) %>%
            dplyr::arrange(desc(labz)) %>%
            ggplot2::ggplot(., aes(tpm, Value)) +
            geom_point(aes(color = labz, size = labz)) +
            geom_smooth(method = "lm") +
            facet_wrap(samplez ~ Feature, scales = "free") +
            scale_x_log10(
              labels = scales::trans_format(
                "log10", 
                scales::math_format(10 ^ .x)
              )
            ) +
            plot_theme +
            scale_color_manual(guide = "none",
                               values = c("firebrick3", "grey70")) +
            labs(x = expression(paste(log[10], "(TPM)"))) +
            scale_size_manual(values = c(4, 1), guide = "none")
        }
      })
    })
    
  } else {
    
    output$features_plot <- shiny::renderPlot({
      input$apply_changes
      shiny::isolate({
        # this is simply a dummy plot to plot nothing
        ggplot2::ggplot(mtcars, aes(x = wt, y = mpg)) +
          geom_blank() +
          theme_void()
      })
    })

  }

}

#
# END SERVER FUNCTION
#

###############################################################################
# UI design
###############################################################################

ui <- shiny::fluidPage(# App title
  shiny::headerPanel("riboviz2"),

  # Sidebar panel for inputs
  shiny::fluidRow(column(
    12,
    shiny::wellPanel(
      shiny::checkboxGroupInput(
        inputId = "sample",
        label = "Sample:",
        choiceNames = names(sample_names),
        choiceValues = names(sample_names),
        selected = names(sample_names)[1],
        inline = TRUE,
        width = "100%"
      ),
      shiny::actionButton("apply_changes", "Apply Changes")
    )

  )),

  # Main panel for displaying outputs
  shiny::mainPanel(width = 12,
            shiny::fluidRow(
              shiny::tabsetPanel(
                shiny::tabPanel(
                  "Read count summary",
                  shiny::headerPanel(""),
                  shiny::plotOutput("read_counts_bar_plot")
                ),

                shiny::tabPanel(
                  "TPM summary",
                  shiny::wellPanel(textInput(
                    inputId = "gene",
                    label = "Gene:",
                    value = collated_tpms_df$ORF[1],
                    width = "50%"
                  )),
                  shiny::headerPanel(""),
                  shiny::plotOutput("sample_cors_plot"),
                  shiny::headerPanel(""),
                  shiny::plotOutput("tpm_density_plot")
                ),

                shiny::tabPanel(
                  "Read length distributions",
                  shiny::headerPanel(""),
                  shiny::plotOutput("read_length_dist_plot")
                ),

                shiny::tabPanel(
                  "3nt periodicity",
                  shiny::headerPanel(""),
                  shiny::plotOutput("periodicity_line_plot"),
                  shiny::headerPanel(""),
                  shiny::plotOutput("frame_counts_bar_plot"),
                  shiny::headerPanel(""),
                  shiny::plotOutput("frame_proportions_boxplot")
                ),

                shiny::tabPanel(
                  "Normalized reads by position",
                  shiny::headerPanel(""),
                  shiny::plotOutput("pos_sp_plot5"),
                  shiny::headerPanel(""),
                  shiny::plotOutput("pos_sp_plot3")
                ),

                shiny::tabPanel(
                  "Gene specific coverage",
                  shiny::wellPanel(textInput(
                    inputId = "gene",
                    label = "Gene:",
                    value = collated_tpms_df$ORF[1],
                    width = "50%"
                  )),
                  shiny::uiOutput("gene_specific_slider"),
                  shiny::headerPanel(""),
                  shiny::plotOutput("sgribogrid_plot")
                ),

                shiny::tabPanel(
                  "Ribogrid",
                  shiny::sliderInput(
                    "ribogrid_len_range",
                    "Read lengths:",
                    min = 0,
                    max = 50,
                    value = c(20, 35),
                    width = "50%"
                  ),
                  shiny::sliderInput(
                    "ribogrid_pos_range",
                    "Read position:",
                    min = -24,
                    max = 50,
                    value = c(-10, 10),
                    width = "50%"
                  ),
                  shiny::headerPanel(""),
                  shiny::plotOutput("ribogrid_plot"),
                  shiny::headerPanel(""),
                  shiny::plotOutput("ribogridbar_plot", height = "1000px")
                ),

                shiny::tabPanel(
                  "Features",
                  shiny::wellPanel(textInput(
                    inputId = "gene2",
                    label = "Gene:",
                    value = collated_tpms_df$ORF[1],
                    width = "50%"
                  ),
                  if (any(names(yaml) == "features_file") &&
                      length(yaml$features_file) > 0) {
                    shiny::checkboxGroupInput(
                      inputId = "feature",
                      label = "Feature:",
                      choiceNames = possible_features,
                      choiceValues = possible_features,
                      selected = possible_features[1],
                      inline = TRUE,
                      width = "100%"
                    )
                  }),
                  shiny::headerPanel(""),
                  shiny::plotOutput("features_plot", height = "1000px")
                )
              )
            )))

# I cast spell, ~run shiny app~
shiny::shinyApp(ui, server, options = list(port = port_num))